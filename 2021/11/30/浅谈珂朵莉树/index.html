<!-- build time:Sun Jul 27 2025 12:02:03 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Keep moving forward" href="https://123hh2.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Keep moving forward" href="https://123hh2.github.io/atom.xml"><link rel="alternate" type="application/json" title="Keep moving forward" href="https://123hh2.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="ODT"><link rel="canonical" href="https://123hh2.github.io/2021/11/30/%E6%B5%85%E8%B0%88%E7%8F%82%E6%9C%B5%E8%8E%89%E6%A0%91/"><title>浅谈珂朵莉树 - 算法学习 | 123hh2 = Keep moving forward</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 7.0.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">浅谈珂朵莉树</h1><div class="meta"><span class="item" title="创建时间：2021-11-30 18:34:55"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2021-11-30T18:34:55+08:00">2021-11-30</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">123hh2</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="http://www.dmoe.cc/random.php?692067"></li><li class="item" data-background-image="http://www.dmoe.cc/random.php?321005"></li><li class="item" data-background-image="http://www.dmoe.cc/random.php?986600"></li><li class="item" data-background-image="http://www.dmoe.cc/random.php?974927"></li><li class="item" data-background-image="http://www.dmoe.cc/random.php?114035"></li><li class="item" data-background-image="http://www.dmoe.cc/random.php?186885"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/" itemprop="item" rel="index" title="分类于 算法学习"><span itemprop="name">算法学习</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://123hh2.github.io/2021/11/30/%E6%B5%85%E8%B0%88%E7%8F%82%E6%9C%B5%E8%8E%89%E6%A0%91/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="123hh2"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Keep moving forward"></span><div class="body md" itemprop="articleBody"><h2 id="珂朵莉树！"><a href="#珂朵莉树！" class="headerlink" title="珂朵莉树！"></a>珂朵莉树！</h2><p>先放个链接：<span class="exturl" data-url="aHR0cHM6Ly96aC5tb2VnaXJsLm9yZy5jbi8lRTclOEYlODIlRTYlOUMlQjUlRTglOEUlODklQzIlQjclRTglQUYlQkElRTUlQTElOTQlQzIlQjclRTclOTElOUYlRTUlQjAlQkMlRTYlQUMlQTclRTklODclOEMlRTYlOTYlQUY=">クトリ！</span></p><hr><p>最近模拟赛考的都好奇怪，$T1$ 怎么想都没想到居然是建 $26$ 颗权值线段树然后瞎勾⑧跑就能过，但好像都跑的挺慢的，然后我去搜题解，发现居然能 $TM$ 用珂朵莉树 <del>水</del> 过去？？？</p><p>水个 p，直接拿了个第二优解</p><p>$Renamoe$ 常数超小%%%</p><p>然后贺完题解的我并不知道珂朵莉树到底怎么写，于是就拿出了一部分的 <del>颓废</del> 时间来学习这个 <del>毒瘤</del> 珂爱的数据结构</p><p>以上吹水言论应该全部删除！（</p><p>下面进入正题</p><hr><p>首先我们先看珂朵莉树的经典例题 <span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vQ0Y4OTZD">CF896C</span>，珂朵莉树就是在这场比赛中诞生的</p><h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>要求我们写一个毒瘤数据结构，可以支持</p><ul><li><p>1 $l,r,x$ : 将 $[l,r]$ 区间全部加上 $x$</p></li><li><p>2 $l,r,x$ : 将 $[l,r]$ 区间全都赋值为 $x$</p></li><li><p>3 $l,r,x$ : 输出将 $[l,r]$ 区间从小到大排序后的第 $x$ 个数是的多少(即区间第 $x$ 小，数字大小相同算多次，保证 $1 \le x \le r-l+1$)</p></li><li><p>4 $l,r,x$ : 输出 $[l,r]$ 区间每个数字的 $x$ 次方的和模 $y$ 的值(即 $\sum^{r}_{i=l} a^{x}_{i})\mod y$)</p></li></ul><p>乍一看可以用主席树套线段树写（我不知道对不对，我瞎想的）</p><p>但是由于本人太菜了，不会写，并且今天学习的主题是珂朵莉树，所以我们就用珂朵莉树来写这道题</p><p>首先我们需要一个的东西 ： $set$，因为珂朵莉树就是基于 $set$ 实现的</p><p>那么我们这个 $set$ 集合里都存些什么呢？</p><p>我们在一个序列上进行区间操作，首先肯定能想到会有左端点右端点和修改值对不对？</p><p>所以我们的结构体里存放的是当前这个集合里的左端点 $l$，右端点 $r$ 和当前区间存的权值</p><p>你可能会很好奇，当前区间的权值要怎么存？难道要一个一个存吗？</p><p>当然不！我们的集合的的权值表示的是这个集合包括的区间里所有的数的权值</p><p>所以每一个集合维护了一个序列上的相同区间的权值和该区间的左右端点</p><p>那么假设我们的序列的数各不相同或者是不连续的该怎么办？这样子的话我们的集合会开到 $n$ 个，这不就跟暴力一样了吗？（其实比暴力更慢）</p><p>我们注意到这一个操作：</p><ul><li>2 $l,r,x$ : 将 $[l,r]$ 区间全都赋值为 $x$</li></ul><p>这个操作其实就是在帮我们降低珂朵莉树的复杂度，因为将一段区间赋值为相同的数，就相当于将这一段区间中的集合全都并起来揉成一个区间了</p><p>PS： 有关珂朵莉树复杂度的证明 <span class="exturl" data-url="aHR0cDovL2NvZGVmb3JjZXMuY29tL2Jsb2cvZW50cnkvNTYxMzU/I2NvbW1lbnQtMzk4OTQw">Codeforces 上关于珂朵莉树的复杂度的证明</span></p><p>好，接下来给出结构体代码</p><pre><code class="lang-cpp">//珂朵莉树基于 set
//开一个集合，每个集合用一个结构体 A 表示
//结构体 A 里存放的分别是 l：目前这一段区间的左端点
//r：目前这一段区间的右端点
//val：目前这一区间的每个元素的值，这段区间的元素的值一定都是相等的
//发现 val 带了一个前缀 mutable，意为 可变的
//因为我们可能会随时更改某一区间的元素值
struct A
&#123;
    long long l,r;mutable long long val;
    bool operator &lt;(const A &amp;now) const&#123;return l&lt;now.l;&#125;
    //保证集合是按区间从左往右排序好了的
    A(long long nowl,long long nowr,long long nowval) :l(nowl),r(nowr),val(nowval) &#123;&#125;
    A(long long nowl) :l(nowl) &#123;&#125;
&#125;;//set 里的结构体 
set&lt;A&gt; s;
</code></pre><p>好，我们的珂朵莉树已经建完了！就下来的操作相信聪明的你一定能够写出来，现在就去试试吧！ <span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vQ0Y4OTZD">CF896C</span>（雾</p><p>接下来我们依次考虑题目中给的每个操作</p><ul><li>1 $l,r,x$ : 将 $[l,r]$ 区间全部赋值为 $x$</li></ul><p>我们应该怎样在我们的集合中操作呢？</p><p>下面介绍一个暴力的函数 —- $split$</p><p>它将当前 $pos$ 所在的集合暴力拆分成两个集合</p><p>其对应的区间分别是 $[l,pos-1]$，$[pos,r]$，然后我们返回后一个集合对应的指针进行操作</p><p>为什么是后一个集合？<del>废话</del> 因为后边的集合包括了你当前需要进行操作的 $pos$</p><h4 id="下面给出-split-代码"><a href="#下面给出-split-代码" class="headerlink" title="下面给出 $split$ 代码"></a>下面给出 $split$ 代码</h4><pre><code class="lang-cpp">set&lt;A&gt;::iterator split(long long pos)//核心操作 split 用来分裂集合用的 
&#123;
    set&lt;A&gt;::iterator it=s.lower_bound(A(pos));//查找当前位置在哪个集合中 
    if(it!=s.end()&amp;&amp;it-&gt;l==pos) return it;//找到了直接返回 
    it--;//这样的话找到了s.end()到头了或者是恰好大于等于上一个集合的r，往回跳一个就是了 
    long long l=it-&gt;l,r=it-&gt;r,val=it-&gt;val;//把当前集合的信息提取出来 
    s.erase(it);//删掉这个集合
    //下面将这个集合分裂成两个集合
    //区间分别为 l-&gt;pos-1 和 pos-&gt;r
    s.insert(A(l,pos-1,val)); 
    return s.insert(A(pos,r,val)).first;//返回后一个集合的指针，因为我们的 pos 包含在了这个集合中 
&#125;
</code></pre><p>这样我们就能实现集合之间的暴力拆了</p><p>那么你可能就想到了一个问题</p><p>如果这个集合一直分裂下去，迟早有一天会分裂成一个个小集合，那不比暴力还暴力吗？</p><p>所以</p><ul><li>2 $l,r,x$ : 将 $[l,r]$ 区间全部赋值为 $x$</li></ul><p>就是一个重要的操作了，这个操作可以让我们将一些零散的集合重新合并成一个大集合</p><h4 id="那么我们写一个对应的函数来实现这个操作，函数命名为-assign"><a href="#那么我们写一个对应的函数来实现这个操作，函数命名为-assign" class="headerlink" title="那么我们写一个对应的函数来实现这个操作，函数命名为 $assign$"></a>那么我们写一个对应的函数来实现这个操作，函数命名为 $assign$</h4><pre><code class="lang-cpp">void assign(long long l,long long r,long long val)//另一个核心操作，用于降低珂朵莉树的复杂度和进行区间赋值操作 
&#123;
    set&lt;A&gt;::iterator it2=split(r+1),it1=split(l);//将我要赋值的区间的端点所对应的集合指针找出来
    //为什么先找 r+1，再找 l？
    //因为 split 中有删除和添加操作，如果我先找 l，那么必定会对后续找 r+1 影响，从而 WA 或 RE 
    //而先找 r+1 再找 l 就不会出现这样的问题了 
    s.erase(it1,it2);//将这一段区间里的所有集合统统清除！ 
    s.insert((A)&#123;l,r,val&#125;);//加入一个大集合表示 l到r 的权值全是val 
&#125;
</code></pre><p>好了，区间赋值操作我们也搞好了，这道题我们就基本快完成了（因为这两个函数是珂朵莉树的核心操作）</p><h4 id="接下来看区间加的操作"><a href="#接下来看区间加的操作" class="headerlink" title="接下来看区间加的操作"></a>接下来看区间加的操作</h4><ul><li>1 $l,r,x$ : 将 $[l,r]$ 区间全部加上 $x$</li></ul><pre><code class="lang-cpp">void add(long long l,long long r,long long val)//区间赋值操作 
&#123;
    set&lt;A&gt;::iterator it2=split(r+1),it1=split(l);//暴力拆集合 
    for(set&lt;A&gt;::iterator it=it1;it!=it2;it++) it-&gt;val+=val;//暴力加值
    //总结：简单粗暴 qwq 
&#125;
</code></pre><p>没什么好说的，将 $[l,r]$ 区间通过 $split$ 操作暴力拆出来，然后再把这个区间里的所有集合所表示的值全都加上 $val$ 就好了</p><h4 id="求区间第-K-小"><a href="#求区间第-K-小" class="headerlink" title="求区间第 $K$ 小"></a>求区间第 $K$ 小</h4><ul><li>3 $l,r,x$ : 输出将 $[l,r]$ 区间从小到大排序后的第 $x$ 个数是的多少(即区间第 $x$ 小，数字大小相同算多次，保证 $1 \le x \le r-l+1$)</li></ul><pre><code class="lang-cpp">long long get_kth(long long l,long long r,long long k)//求区间第 K 小 
&#123;
    set&lt;A&gt;::iterator it2=split(r+1),it1=split(l);//还是暴力拆区间 
    vector&lt;pair&lt;long long,long long&gt; &gt; q;q.clear();//开个 vector 存当前区间里集合的值和其对应的区间长度 
    for(set&lt;A&gt;::iterator it=it1;it!=it2;it++) q.push_back(pair&lt;long long,long long&gt;(it-&gt;val,it-&gt;r-it-&gt;l+1));//存起来！ 
    sort(q.begin(),q.end());//默认按照 pair 第一个元素从小到大排序 
    for(ri long long i=0;i&lt;q.size();i++)//正序遍历求第 K 小
    &#123;
        k-=q[i].second;//每次减掉这个区间的长度 
        if(k&lt;=0) return q[i].first;//小于等于 0 了说明这个区间里包含了我们要查询的第 K 小值，直接返回就好了 
    &#125;
&#125;
</code></pre><p>也是暴力的拆集合，然后把当前区间里包含的集合全部掏出来排个序，然后暴力求个第 $K$ 小就好了</p><h4 id="最后一个操作，求区间每个数的-x-次幂模-y-的和"><a href="#最后一个操作，求区间每个数的-x-次幂模-y-的和" class="headerlink" title="最后一个操作，求区间每个数的 $x$ 次幂模 $y$ 的和"></a>最后一个操作，求区间每个数的 $x$ 次幂模 $y$ 的和</h4><pre><code class="lang-cpp">inline long long fstpow(long long n,long long m,long long md)//快速幂，别傻到暴力求 x 次幂（ 
&#123;
    long long ans=1ll,base=n;base%=md;
    while(m)
    &#123;
        if(m&amp;1) ans*=base,ans%=md;
        base*=base,base%=md,m&gt;&gt;=1;
    &#125;
    return ans;
&#125;
long long query(long long l,long long r,long long x,long long y)
&#123;
    long long ans=0;
    set&lt;A&gt;::iterator it2=split(r+1),it1=split(l);//依旧暴力拆区间
    //对于每个集合，暴力求和 
    for(set&lt;A&gt;::iterator it=it1;it!=it2;it++) ans+=fstpow(it-&gt;val,x,y)*(it-&gt;r-it-&gt;l+1),ans%=y;
    return ans;
&#125;
</code></pre><p>$OK$ 到此，我们已经把这道题所有的关键操作写完了，下面上一下整体代码</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;
#define ri register
using namespace std;
inline long long read()
&#123;
    long long x=0,f=1;char ch=getchar();while(ch&gt;&#39;9&#39;||ch&lt;&#39;0&#39;) &#123;if(ch==&#39;-&#39;) f=-1;ch=getchar();&#125;
    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;) &#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48);ch=getchar();&#125;return x*f;
&#125;
inline void write(long long x) &#123;if(x&lt;0) &#123;x=-x;putchar(&#39;-&#39;);&#125;if(x&gt;9) write(x/10);putchar(x%10+&#39;0&#39;);&#125;
const long long mod=1e9+7,maxn=1e5+1;
long long n,m,seed,vmax,awa[maxn];
inline long long myrand() &#123;long long ret=seed;seed=(seed*7ll+13ll)%mod;return ret;&#125;
//珂朵莉树基于 set
//开一个集合，每个集合用一个结构体 A 表示
//结构体 A 里存放的分别是 l：目前这一段区间的左端点
//r：目前这一段区间的右端点
//val：目前这一区间的每个元素的值，注意这段区间的元素的值一定都是相等的
//发现 val 带了一个前缀 mutable，意为 可变的
//因为我们可能会随时更改某一区间的元素值 
struct A
&#123;
    long long l,r;mutable long long val;
    bool operator &lt;(const A &amp;now) const&#123;return l&lt;now.l;&#125;
    //保证集合是按区间从左往右排序好了的
    A(long long nowl,long long nowr,long long nowval) :l(nowl),r(nowr),val(nowval) &#123;&#125;
    A(long long nowl) :l(nowl) &#123;&#125;
&#125;;//set 里的结构体 
set&lt;A&gt; s;
set&lt;A&gt;::iterator split(long long pos)//核心操作 split 用来分裂集合用的 
&#123;
    set&lt;A&gt;::iterator it=s.lower_bound(A(pos));//查找当前位置在哪个集合中 
    if(it!=s.end()&amp;&amp;it-&gt;l==pos) return it;//找到了直接返回 
    it--;//这样的话找到了s.end()到头了或者是恰好大于等于上一个集合的r，往回跳一个就是了 
    long long l=it-&gt;l,r=it-&gt;r,val=it-&gt;val;//把当前集合的信息提取出来 
    s.erase(it);//删掉这个集合
    //下面将这个集合分裂成两个集合
    //区间分别为 l-&gt;pos-1 和 pos-&gt;r
    s.insert(A(l,pos-1,val)); 
    return s.insert(A(pos,r,val)).first;//返回后一个集合的指针，因为我们的 pos 包含在了这个集合中 
&#125;
void assign(long long l,long long r,long long val)//另一个核心操作，用于降低珂朵莉树的复杂度和进行区间赋值操作 
&#123;
    set&lt;A&gt;::iterator it2=split(r+1),it1=split(l);//将我要赋值的区间的端点所对应的集合指针找出来
    //为什么先找 r+1，再找 l？
    //因为 split 中有删除和添加操作，如果我先找 l，那么必定会对后续找 r+1 影响，从而 WA 或 RE 
    //而先找 r+1 再找 l 就不会出现这样的问题了 
    s.erase(it1,it2);//将这一段区间里的所有集合统统清除！ 
    s.insert((A)&#123;l,r,val&#125;);//加入一个大集合表示 l到r 的权值全是val 
&#125;
void add(long long l,long long r,long long val)//区间赋值操作 
&#123;
    set&lt;A&gt;::iterator it2=split(r+1),it1=split(l);//暴力拆集合 
    for(set&lt;A&gt;::iterator it=it1;it!=it2;it++) it-&gt;val+=val;//暴力加值
    //总结：简单粗暴 qwq 
&#125;
long long get_kth(long long l,long long r,long long k)//求区间第 K 小 
&#123;
    set&lt;A&gt;::iterator it2=split(r+1),it1=split(l);//还是暴力拆区间 
    vector&lt;pair&lt;long long,long long&gt; &gt; q;q.clear();//开个 vector 存当前区间里集合的值和其对应的区间长度 
    for(set&lt;A&gt;::iterator it=it1;it!=it2;it++) q.push_back(pair&lt;long long,long long&gt;(it-&gt;val,it-&gt;r-it-&gt;l+1));//存起来！ 
    sort(q.begin(),q.end());//默认按照 pair 第一个元素从小到大排序 
    for(ri long long i=0;i&lt;q.size();i++)//正序遍历求第 K 小
    &#123;
        k-=q[i].second;//每次减掉这个区间的长度 
        if(k&lt;=0) return q[i].first;//小于等于 0 了说明这个区间里包含了我们要查询的第 K 小值，直接返回就好了 
    &#125;
&#125;
inline long long fstpow(long long n,long long m,long long md)//快速幂，别傻到暴力求 x 次幂（ 
&#123;
    long long ans=1ll,base=n;base%=md;
    while(m)
    &#123;
        if(m&amp;1) ans*=base,ans%=md;
        base*=base,base%=md,m&gt;&gt;=1;
    &#125;
    return ans;
&#125;
long long query(long long l,long long r,long long x,long long y)
&#123;
    long long ans=0;
    set&lt;A&gt;::iterator it2=split(r+1),it1=split(l);//依旧暴力拆区间
    //对于每个集合，暴力求和 
    for(set&lt;A&gt;::iterator it=it1;it!=it2;it++) ans+=fstpow(it-&gt;val,x,y)*(it-&gt;r-it-&gt;l+1),ans%=y;
    return ans;
&#125;
signed main()
&#123;
    n=read(),m=read(),seed=read(),vmax=read();
    for(ri long long i=1;i&lt;=n;i++) &#123;awa[i]=myrand()%vmax+1;s.insert(A(i,i,awa[i]));&#125;//初始化每个集合 
    s.insert(A(n+1,n+1,0));//最后的一个小区间,防止访问越界 
    for(ri long long i=1;i&lt;=m;i++)
    &#123;
        //以下为生成数据 
        long long x,y,opt=myrand()%4+1,l=myrand()%n+1,r=myrand()%n+1;
//        cout&lt;&lt;opt&lt;&lt;&quot; &quot;&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;endl;
        if(l&gt;r) swap(l,r);
        if(opt==3) x=myrand()%(r-l+1)+1;
        else x=myrand()%vmax+1;
        if(opt==4) y=(myrand()%vmax)+1;
        //以上为生成数据 
        if(opt==1) &#123;add(l,r,x);continue;&#125;//区间加 
        if(opt==2) &#123;assign(l,r,x);continue;&#125;//区间改 
        if(opt==3) &#123;write(get_kth(l,r,x)),puts(&quot;&quot;);continue;&#125;//查找第 K 大 
        if(opt==4) &#123;write(query(l,r,x,y)),puts(&quot;&quot;);continue;&#125;//查询区间每个数 x 次方模 y 的和 
    &#125;
    return 0;//没啦！ 
&#125;
</code></pre><p>下面给出一些注意事项</p><ul><li><p>注意 $split$ 的时候最好要先 $split(r+1)$ 再 $split(l)$</p></li><li><p>注意 $split$ 返回的是包含当前分裂点的集合的指针</p></li><li><p>注意在初始化集合的时候在集合最后在加一个 $n+1$ 的值任意的集合，防止查找的时候越界</p></li></ul><p>最后的时候说一下什么时候可以用珂朵莉树来做题</p><p><strong>涉及到区间修改，区间赋值，区间查询并且数据随机的情况下使用</strong></p><p>其中最重要的一点就是 <strong>区间赋值操作</strong> 和 <strong>数据随机</strong></p><p>珂朵莉树的复杂度就是在这两个前提条件下保证的</p><hr><p>没啦！这玩意调了好长时间都没调过，我先把博文放出来，等什么时候修好锅了再回来改</p><p>upd:锅已修好，取模问题</p><div class="tags"><a href="/tags/ODT/" rel="tag"><i class="ic i-tag"></i> ODT</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2025-07-27 11:16:51" itemprop="dateModified" datetime="2025-07-27T11:16:51+08:00">2025-07-27</time> </span><span id="2021/11/30/浅谈珂朵莉树/" class="item leancloud_visitors" data-flag-title="浅谈珂朵莉树" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="123hh2 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="123hh2 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="123hh2 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>123hh2 <i class="ic i-at"><em>@</em></i>Keep moving forward</li><li class="link"><strong>本文链接：</strong> <a href="https://123hh2.github.io/2021/11/30/%E6%B5%85%E8%B0%88%E7%8F%82%E6%9C%B5%E8%8E%89%E6%A0%91/" title="浅谈珂朵莉树">https://123hh2.github.io/2021/11/30/浅谈珂朵莉树/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"></div><div class="item right"><a href="/2023/12/02/CF1899E-Queue-Sort/" itemprop="url" rel="next" data-background-image="http:&#x2F;&#x2F;www.dmoe.cc&#x2F;random.php?529104" title="CF1899E Queue Sort"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> CF题解</span><h3>CF1899E Queue Sort</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8F%82%E6%9C%B5%E8%8E%89%E6%A0%91%EF%BC%81"><span class="toc-number">1.</span> <span class="toc-text">珂朵莉树！</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F"><span class="toc-number">1.0.1.</span> <span class="toc-text">题目大意</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E9%9D%A2%E7%BB%99%E5%87%BA-split-%E4%BB%A3%E7%A0%81"><span class="toc-number">1.0.2.</span> <span class="toc-text">下面给出 $split$ 代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%A3%E4%B9%88%E6%88%91%E4%BB%AC%E5%86%99%E4%B8%80%E4%B8%AA%E5%AF%B9%E5%BA%94%E7%9A%84%E5%87%BD%E6%95%B0%E6%9D%A5%E5%AE%9E%E7%8E%B0%E8%BF%99%E4%B8%AA%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%87%BD%E6%95%B0%E5%91%BD%E5%90%8D%E4%B8%BA-assign"><span class="toc-number">1.0.3.</span> <span class="toc-text">那么我们写一个对应的函数来实现这个操作，函数命名为 $assign$</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E4%B8%8B%E6%9D%A5%E7%9C%8B%E5%8C%BA%E9%97%B4%E5%8A%A0%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.0.4.</span> <span class="toc-text">接下来看区间加的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82%E5%8C%BA%E9%97%B4%E7%AC%AC-K-%E5%B0%8F"><span class="toc-number">1.0.5.</span> <span class="toc-text">求区间第 $K$ 小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%EF%BC%8C%E6%B1%82%E5%8C%BA%E9%97%B4%E6%AF%8F%E4%B8%AA%E6%95%B0%E7%9A%84-x-%E6%AC%A1%E5%B9%82%E6%A8%A1-y-%E7%9A%84%E5%92%8C"><span class="toc-number">1.0.6.</span> <span class="toc-text">最后一个操作，求区间每个数的 $x$ 次幂模 $y$ 的和</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/2021/11/30/%E6%B5%85%E8%B0%88%E7%8F%82%E6%9C%B5%E8%8E%89%E6%A0%91/" rel="bookmark" title="浅谈珂朵莉树">浅谈珂朵莉树</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="123hh2" data-src="/images/avatar.jpg"><p class="name" itemprop="name">123hh2</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">9</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">3</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">10</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tLzEyM2hoMg==" title="https:&#x2F;&#x2F;github.com&#x2F;123hh2"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS81Ni0yLTI0LTIw" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;56-2-24-20"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTM5OTU0MDQ0OTk=" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;3995404499"><i class="ic i-cloud-music"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjE3OTYzNzI4NTBAcXEuY29t" title="mailto:1796372850@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/CF%E9%A2%98%E8%A7%A3/" title="分类于 CF题解">CF题解</a></div><span><a href="/2023/12/05/CF1891C-Smilo-and-Monsters/" title="CF1891C Smilo and Monsters">CF1891C Smilo and Monsters</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CF%E9%A2%98%E8%A7%A3/" title="分类于 CF题解">CF题解</a></div><span><a href="/2023/12/02/CF1899E-Queue-Sort/" title="CF1899E Queue Sort">CF1899E Queue Sort</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CF%E9%A2%98%E8%A7%A3/" title="分类于 CF题解">CF题解</a></div><span><a href="/2023/12/09/CF1898D-Absolute-Beauty/" title="CF1898D Absolute Beauty">CF1898D Absolute Beauty</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/" title="分类于 算法学习">算法学习</a></div><span><a href="/2021/11/30/%E6%B5%85%E8%B0%88%E7%8F%82%E6%9C%B5%E8%8E%89%E6%A0%91/" title="浅谈珂朵莉树">浅谈珂朵莉树</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/AtCoder%E9%A2%98%E8%A7%A3/" title="分类于 AtCoder题解">AtCoder题解</a></div><span><a href="/2025/07/27/AtCoder-Beginner-Contest-416/" title="AtCoder-Beginner-Contest-416">AtCoder-Beginner-Contest-416</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CF%E9%A2%98%E8%A7%A3/" title="分类于 CF题解">CF题解</a></div><span><a href="/2023/12/09/CF1899F-Alex-s-whims/" title="CF1899F Alex&#39;s whims">CF1899F Alex's whims</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CF%E9%A2%98%E8%A7%A3/" title="分类于 CF题解">CF题解</a></div><span><a href="/2023/12/07/CF1898C-Colorful-Grid/" title="CF1898C Colorful Grid">CF1898C Colorful Grid</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CF%E9%A2%98%E8%A7%A3/" title="分类于 CF题解">CF题解</a></div><span><a href="/2023/12/03/CF1898B-Milena-and-Admirer/" title="CF1898B Milena and Admirer">CF1898B Milena and Admirer</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CF%E9%A2%98%E8%A7%A3/" title="分类于 CF题解">CF题解</a></div><span><a href="/2023/12/06/Codeforces-Round-913-Div-3-A-F/" title="Codeforces Round 913 (Div. 3)A~F">Codeforces Round 913 (Div. 3)A~F</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">123hh2 @ 123hh2</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2021/11/30/浅谈珂朵莉树/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->